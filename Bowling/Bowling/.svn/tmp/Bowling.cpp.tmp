// EMERGENT GAME TECHNOLOGIES PROPRIETARY INFORMATION
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement with Emergent Game Technologies and may not 
// be copied or disclosed except in accordance with the terms of that 
// agreement.
//
//      Copyright (c) 1996-2009 Emergent Game Technologies.
//      All Rights Reserved.
//
// Emergent Game Technologies, Chapel Hill, North Carolina 27517
// http://www.emergent.net

#include <NiMain.h>

#include "Bowling.h"

#include <NiLicense.h>

#include "GameStateManager.h"
#include "GameState.h"
#include "RunningState.h"
#include "InitializeState.h"
#include "LoadState.h"
#include "NewGameMenu.h"
#include <NiUIManager.h>

NiEmbedGamebryoLicenseCode;

//---------------------------------------------------------------------------
NiApplication* NiApplication::Create()
{
    return NiNew Bowling;
}
//---------------------------------------------------------------------------
Bowling::Bowling() : NiSample("T&T Bowling",
    DEFAULT_WIDTH, DEFAULT_HEIGHT, true), 
	m_PhysContactReporter()
{
    // Tell Gamebryo where to find its data files.
#if defined(WIN32) && !defined(_XBOX)
    SetMediaPath("../Data/Win32/");   
#elif defined(_PS3)
    SetMediaPath("../../../../Data/PS3/");   
#elif defined(_WII)
    SetMediaPath("/Tutorials/PhysX/Data/Wii/");
#elif defined(_XBOX)
    SetMediaPath("D:/DATA/Win32/");
#endif // defined(WIN32) && !defined(_XBOX)

#if defined(_XENON)
    SetUISkinFilename("D:\\Data\\UISkinFull.dds");
#elif defined(_PS3)
    NIVERIFY(FindSampleDataFile("UISkinFull_ps3.dds", m_acSkinPath));
#elif defined(WIN32)
    NIVERIFY(FindSampleDataFile("UISkinFull.dds", m_acSkinPath));
#elif defined(_WII)
    SetUISkinFilename("/Data/UISkinFull_wii.dds");
#else
#error "Unsupported platform"
#endif

	m_PhysContactReporter.m_app = this;

    m_spTrnNode = 0;
    m_spRotNode = 0;
    
    // Initialize smart pointers to zero. In the case of early termination
    // this avoid errors.
    m_spPhysScene = 0;

	GameStateManager::getInstance()->addApplication(this);
	GameStateManager::getInstance()->start(RunningState::getInstance());

	m_kWelcomeColor = NiColorA(1.0f, 0.0f, 0.0f, 1.0f);
    m_uiFlags = NiFontString::COLORED | NiFontString::CENTERED;
    m_kUnicodeRenderClickName = "Unicode Render Click";
}
//---------------------------------------------------------------------------
Bowling::~Bowling()
{
}
//---------------------------------------------------------------------------
bool Bowling::Initialize()
{
	GameStateManager::getInstance()->pushState(InitializeState::getInstance());

    // Save a pointer to the PhysXSDKManager object. This is Emergent's
    // manager for all PhysX global functionality. The file
    // <efdPhysX/PhysXSDKManager.h> must be included for this object to exist.
    m_pkPhysManager = efdPhysX::PhysXSDKManager::GetManager();
    
    // Try to initialize the PhysX SDK. By default, we are setting up
    // Gamebryo's memory manager and debug output interfaces for use
    // with PhysX.
    if (!m_pkPhysManager->Initialize())
    {
        char acMsg[1024];
        NiSprintf(acMsg, 1024,
            "Unable to initialize PhysX SDK version %d.\n"
            "This may mean you don't have PhysX installed.\n"
            "Have you installed PhysX System Software and Core?\n",
            NX_SDK_VERSION_NUMBER);
        NiMessageBox(acMsg,
            "PhysX Initialization Failed");
        return false;
    }
        
    // The manager contains a public pointer to the PhysX SDK object,
    // m_pkPhysXSDK. Here we use it to set some global SDK parameters.
    // See the PhysX documentation for an explanation of these settings.
    m_pkPhysManager->m_pPhysXSDK->setParameter(NX_SKIN_WIDTH, 0.01f);
    m_pkPhysManager->m_pPhysXSDK->setParameter(NX_BOUNCE_THRESHOLD, -0.75f);
    m_pkPhysManager->m_pPhysXSDK->setParameter(NX_VISUALIZATION_SCALE, 2.0f);
    m_pkPhysManager->m_pPhysXSDK->setParameter(NX_VISUALIZE_BODY_AXES, 1.0f);
    m_pkPhysManager->m_pPhysXSDK->setParameter(NX_VISUALIZE_COLLISION_SHAPES, 1.0f);
	m_pkPhysManager->m_pPhysXSDK->setParameter(NX_VISUALIZE_BODY_LIN_VELOCITY, 1.0f);


    if (!NiApplication::Initialize())
        return false;

	if (!NiSample::CreateUISystem())
		return false;

	if (!CreateUIElements())
		return false;

	if (!NiSample::CompleteUISystem())
		return false;
            
    // Set up camera control
    SetTurretControls();

    // Update the scene graph before rendering begins.
    m_spScene->UpdateProperties();
    m_spScene->UpdateEffects();
    m_spScene->Update(0.0f);

	GameStateManager::getInstance()->physManager = m_pkPhysManager;
	GameStateManager::getInstance()->physScene = m_spPhysScene;
	GameStateManager::getInstance()->scene = m_spScene;
	GameStateManager::getInstance()->changeState(NewGameMenu::getInstance());
    
    return true;
}
//---------------------------------------------------------------------------
void Bowling::Terminate()
{
    m_spTrnNode = 0;
    m_spRotNode = 0;
	spCone = 0;

    // The PhysX scenes should be deleted before the SDK is shut down.
    m_spPhysScene = 0;

    // The PhysX manager must be shut down after all PhysX content has been
    // deleted and before the application terminates.
    m_pkPhysManager->Shutdown();
    
    NiSample::Terminate();
}
//---------------------------------------------------------------------------
bool Bowling::CreateScene()
{
	GameStateManager::getInstance()->pushState(LoadState::getInstance());
    if(!NiApplication::CreateScene())
        return false;

    // Set the background color
    NiColor kColor(0.5f, 0.6f, 1.0f);
    m_spRenderer->SetBackgroundColor(kColor);

	
    
    // We first create a PhysX scene and the Gamebryo wrapper for it. First
    // the wrapper.
    m_spPhysScene = NiNew NiPhysXScene();
    
    // Then the PhysX scene
    NxSceneDesc kSceneDesc;
    kSceneDesc.gravity.set(0.0f, -9.8f, 0.0f);
    NxScene* pkScene = m_pkPhysManager->m_pPhysXSDK->createScene(kSceneDesc);
    NIASSERT(pkScene != 0);
	pkScene->setUserContactReport(&m_PhysContactReporter);
    
    // Attach the physics scene to the wrapper
    m_spPhysScene->SetPhysXScene(pkScene);
    
    // Load some PhysX-enabled content.
    NiStream kStream;
    if (!kStream.Load(ConvertMediaFilename("bowlingAlley.nif")))
	{
        NIASSERT(0 && "Couldn't load nif file\n");
        NiMessageBox("Could not load bowling.nif. Aborting\n",
            "Missing nif file.");
 
        return false;
    }

    // We know that this NIF file has the scene graph at location 0.
    NIASSERT(NiIsKindOf(NiNode, kStream.GetObjectAt(0)));
    m_spScene = (NiNode*)kStream.GetObjectAt(0);

    // We expect the world to have been exported with a camera, so we 
    // look for it here.
    // In order to render the scene graph, we need a camera. We're now going
    // to recurse the scene graph looking for a camera.
	m_spCamera = FindFirstCamera(m_spScene);
    if (!m_spCamera)
    {
        NiMessageBox("The NIF file has no camera!", "Camera Error");
        return false;
    }

    // Look for a camera and the PhysX content. In this case, the PhysX
    // content is the bowling scene.
    NiPhysXPropPtr spLaneProp = 0;
    for (unsigned int ui = 1; ui < kStream.GetObjectCount(); ui++)
    {
        if (NiIsKindOf(NiCamera, kStream.GetObjectAt(ui)))
        {
            //m_spCamera = (NiCamera*)kStream.GetObjectAt(ui);
        }
        else if (NiIsKindOf(NiPhysXProp, kStream.GetObjectAt(ui)))
        {
            // We have found the PhysX content in the NIF.
            spLaneProp = (NiPhysXProp*)kStream.GetObjectAt(ui);
        }
    }
    NIASSERT(spLaneProp != 0);
    
	// This scene contains only the static box, so we do not need to set
    // anything else.
    
    // Repeat the process with the ball.
    kStream.RemoveAllObjects();
    if (!kStream.Load(ConvertMediaFilename("BallText.nif")))
    {
        NIASSERT(0 && "Couldn't load nif file\n");
        NiMessageBox("Could not load Ball.nif. Aborting\n",
            "Missing nif file.");
 
        return false;
    }

    // We know that this NIF file has the ball at location 0. Attach the
    // ball to the scene graph.
    NIASSERT(NiIsKindOf(NiAVObject, kStream.GetObjectAt(0)));
    m_spScene->AttachChild((NiAVObject*)kStream.GetObjectAt(0));

    // Look for the PhysX content.
    //NiPhysXPropPtr spBallProp = 0;
    for (unsigned int ui = 1; ui < kStream.GetObjectCount(); ui++)
    {
        if (NiIsKindOf(NiPhysXProp, kStream.GetObjectAt(ui)))
        {
            // We have found the PhysX content in the NIF.
            spBallProp = (NiPhysXProp*)kStream.GetObjectAt(ui);
        }
    }
    NIASSERT(spBallProp != 0);

	// Repeat the process with the ball.
    kStream.RemoveAllObjects();
    if (!kStream.Load(ConvertMediaFilename("pins2.nif")))
    {
        NIASSERT(0 && "Couldn't load nif file\n");
        NiMessageBox("Could not load Ball.nif. Aborting\n",
            "Missing nif file.");
 
        return false;
    }

    // We know that this NIF file has the pins at location 0. Attach the
    // pins to the scene graph.
    NIASSERT(NiIsKindOf(NiAVObject, kStream.GetObjectAt(0)));
    m_spScene->AttachChild((NiAVObject*)kStream.GetObjectAt(0));
	
	// Look for the PhysX content.
    NiPhysXPropPtr spPinsProp = 0;
    for (unsigned int ui = 1; ui < kStream.GetObjectCount(); ui++)
    {
        if (NiIsKindOf(NiPhysXProp, kStream.GetObjectAt(ui)))
        {
            // We have found the PhysX content in the NIF.
            spPinsProp = (NiPhysXProp*)kStream.GetObjectAt(ui);
        }
    }
    NIASSERT(spPinsProp != 0);

    
    // Now we want the ball and the box to be in the scene.
    // We are doing this after the PhysX scnee has been created. Any props
    // added to a scene after the PhysX scene has been set are automatically
    // instanciated in that scene.
	//m_spPhysScene->AddProp(spCubeProp);
	m_spPhysScene->AddProp(spPinsProp);
    m_spPhysScene->AddProp(spBallProp);
    m_spPhysScene->AddProp(spLaneProp);

    // The ball is a destination object - the Gamebryo scene graph ball
    // receives pose information from the PhysX actor. We need to enable
    // the updating of destinations to start the transfer of information.
    // Each object needs to be enabled and the whole scene. By default the
    // object update is enabled, but the scene update is not.
    m_spPhysScene->SetUpdateDest(true);

	// Show Debug data
	m_spPhysScene->SetDebugRender(true, m_spScene);


	// Setup collision checks
	//NxActor* cylinder = ((NiPhysXRigidBodyDest*)spCylinderProp->GetDestinationAt(0))->GetActor();
	//m_spPhysScene->GetPhysXScene()->setActorPairFlags(*box, *cylinder, NX_NOTIFY_ON_TOUCH | NX_NOTIFY_FORCES);

	//Setup text display
	m_spFont = NiFont::Create( NiRenderer::GetRenderer(),
    NiApplication::ConvertMediaFilename("Font/ArialUnicodeMS_BA_36.nff"));
    if (!m_spFont)
    {
        NiOutputDebugString("ERROR:  NFF Font File Load Failed.\n");
        return false;
    }

	 // Use viewport size to calculate text positions
    unsigned int uiViewportWidth
        = m_spRenderer->GetDefaultBackBuffer()->GetWidth();
    unsigned int uiViewportHeight
        = m_spRenderer->GetDefaultBackBuffer()->GetHeight();

	unsigned int uiWelcomeOffsetX = uiViewportWidth/2;
        unsigned int uiWelcomeOffsetY = uiViewportHeight/3;

        m_spStrWelcome = NiNew Ni2DString(m_spFont, m_uiFlags, 128,
            "Hello", m_kWelcomeColor, 
            (short)uiWelcomeOffsetX,
            (short)uiWelcomeOffsetY);

        if (uiViewportHeight <= 600)
            m_spStrWelcome->SetPointSize(24);
        else if (uiViewportHeight >= 1050)
            m_spStrWelcome->SetPointSize(48);
        else
            m_spStrWelcome->SetPointSize(36);

	CreateScreenElements();


	GameStateManager::getInstance()->popState();
    return true;
}
//---------------------------------------------------------------------------
bool Bowling::CreateFrame()
{
	if (!NiApplication::CreateFrame())
    {
        return false;
    }

    // Create a render click to render the Ni2DString objects.
    Ni2DStringRenderClick* pkUnicodeRenderClick = NiNew Ni2DStringRenderClick;
    pkUnicodeRenderClick->SetName(m_kUnicodeRenderClickName);
    pkUnicodeRenderClick->Append2DString(m_spStrWelcome);

    // Insert render click at the end of the main render step.
    NIASSERT(m_spFrame);
    NiDefaultClickRenderStep* pkScreenSpaceStep = NiDynamicCast(
        NiDefaultClickRenderStep, m_spFrame->GetRenderStepByName(
        m_kScreenSpaceRenderStepName));
    NIASSERT(pkScreenSpaceStep);
    pkScreenSpaceStep->AppendRenderClick(pkUnicodeRenderClick);

    return true;
}
//---------------------------------------------------------------------------
bool Bowling::CreateScreenElements()
{

	NiTexture::FormatPrefs kPrefs;
    kPrefs.m_eMipMapped = NiTexture::FormatPrefs::NO;

    NiTexture* pkBGTexture = NiSourceTexture::Create(
        NiApplication::ConvertMediaFilename("scoresheet.TGA"), kPrefs);
    if (!pkBGTexture)
        return false;

    NiMeshScreenElements* pkScreenPoly = NiNew NiMeshScreenElements(
        false, false, 1);
    if (!pkScreenPoly)
        return false;

    // We know that the polygon handle is zero and will use it directly in the
    // vertex and texture coordinate assignments.
    pkScreenPoly->Insert(4);

    // Account for overscan for consoles.
    // Work-around font rendering/scaling problem on Wii.
#if defined(WIN32) || defined(_WII)
    pkScreenPoly->SetRectangle(0, 0.01f, 0.01f, 0.98f, 0.98f);
#else
    pkScreenPoly->SetRectangle(0, 0.04f, 0.04f, 0.92f, 0.92f);
#endif

    pkScreenPoly->UpdateBound();
    pkScreenPoly->SetTextures(0, 0, 0.01f, 0.01f, 0.99f, 0.7425f);

    NiTexturingProperty* pkTextProp = NiNew NiTexturingProperty;
    if (!pkTextProp)
        return false;

    pkTextProp->SetBaseTexture(pkBGTexture);
    pkTextProp->SetBaseFilterMode(NiTexturingProperty::FILTER_BILERP);
    pkTextProp->SetApplyMode(NiTexturingProperty::APPLY_REPLACE);
    pkScreenPoly->AttachProperty(pkTextProp);

    pkScreenPoly->UpdateProperties();
    pkScreenPoly->Update(0.0f);


    GetScreenElements().AddTail(pkScreenPoly);
    

    return true;
}

//---------------------------------------------------------------------------

bool Bowling::CreateUIElements()
{
	/*
	unsigned int uiWidth, uiHeight;
    NiRenderer::GetRenderer()->ConvertFromNDCToPixels(1.0f, 1.0f, 
        uiWidth, uiHeight);

    NiPoint2 kDimensions(0.0f, 0.0f);

	NiUIButton* menu = NiNew NiUIButton( "New Game" );
	menu->SetDimensions( .3, .125 );
	menu->SetOffset(0,.5);
	menu->SetVisible(true);
	NiUIGroup* pkUIGroup = NiNew NiUIGroup("Bowling!", NiUIManager::GetUIManager()->GetMaxCharHeightInNSC() * 10.0f);
	pkUIGroup->AddChild(menu);

	pkUIGroup->SetDimensions(.33,.33);
	pkUIGroup->SetOffset(.33,.25);
	pkUIGroup->UpdateRect();

	NiUIManager::GetUIManager()->AddUIGroup( pkUIGroup );

	NewGameMenu::getInstance()->setUIGroup( pkUIGroup );
	NiUIManager::GetUIManager()->SetVisible(true);
	*/
	return true;
}

/*
bool Bowling::CreateUISystem()
{
	NiUIManager::Create();
    NiUIManager* pkUIManager = NiUIManager::GetUIManager();
    if (pkUIManager == NULL)
          return false;

	if( !pkUIManager->Initialize( GetInputSystem(), ConvertMediaFilename("UISkin.dds"), m_spCursor ) )
	{
		return false;
	}

	m_fUIElementHeight = pkUIManager->GetMaxCharHeightInNSC() * 3.0f;
    m_fUIElementWidth = NiMin(0.40f,
          pkUIManager->GetMaxCharWidthInNSC() * 25.0f);
    m_fUIGroupHeaderHeight = pkUIManager->GetMaxCharHeightInNSC() * 2.75f;
    m_kUIElementGroupOffset.x = pkUIManager->GetMaxCharWidthInNSC() * 1.5f;
    m_kUIElementGroupOffset.y = pkUIManager->GetMaxCharHeightInNSC() * 0.5f +
          m_fUIGroupHeaderHeight;

    if (m_bUseNavSystem)
    {
          if (!NiNavManager::Create())
                return false;
    }

    NiUIManager::GetUIManager()->ReserveGamePadButton(
          NiInputGamePad::NIGP_A, &m_kHideAll, NiUIManager::WASPRESSED);
    NiUIManager::GetUIManager()->ReserveKeyboardButton(
          NiInputKeyboard::KEY_Z, &m_kHideAll, NiUIManager::WASPRESSED);

	return true;
}
*/

void Bowling::ApplyForceToActor(NxActor* actor, const NxVec3& forceDir, const NxReal forceStrength)
{
	NxReal	gDeltaTime = 1.0/60.0;
	NxVec3 forceVec = forceStrength*forceDir*gDeltaTime;
	actor->addForce(forceVec);
}

//---------------------------------------------------------------------------
void Bowling::ProcessInput()
{
	NxReal gForceStrength = 10000;
    NiApplication::ProcessInput();

	NiInputMouse* pkMouse = GetInputSystem()->GetMouse();

	GameStateManager::getInstance()->processMouse( pkMouse );



    NiInputKeyboard* pkKeyboard = GetInputSystem()->GetKeyboard();
	GameStateManager::getInstance()->processKeyboard(pkKeyboard);


    NiInputGamePad* pkGamePad;
    for (unsigned int uiPort = 0; uiPort < NiInputSystem::MAX_GAMEPADS; 
        uiPort++)
    {
        pkGamePad = m_spInputSystem->GetGamePad(uiPort);

		GameStateManager::getInstance()->processGamePad(pkGamePad);

    }

}
//---------------------------------------------------------------------------
void Bowling::UpdateFrame()
{
   

	NiApplication::UpdateFrame(); // Calls process input
	//NiUIManager::GetUIManager()->UpdateUI();
	GameStateManager::getInstance()->update(m_fAccumTime);


	//soundSystem.Update();

	/*
    // Update the camera. This uses global time.
    if (m_kTurret.Read())
        m_spTrnNode->Update(m_fAccumTime);
		*/ 
	
        
   
}
//---------------------------------------------------------------------------
void Bowling::ResetBall()
{
    // To restore the scene to its initial conditions, we use the data
    // stored in the snapshot that was originally loaded from the NIF file.
    // By default, that is snapshot 0.
    m_spPhysScene->RestoreSnapshotState(0);
	m_ballInMotion = false;
}
//---------------------------------------------------------------------------
void Bowling::SetTurretControls()
{   
    m_spCamera->Update(0.0f);
    m_spTrnNode = NiNew NiNode();
    m_spTrnNode->SetTranslate(m_spCamera->GetWorldTranslate());
    m_spCamera->SetTranslate(NiPoint3::ZERO);
    m_spRotNode = NiNew NiNode();
    m_spTrnNode->AttachChild(m_spRotNode);
    m_spRotNode->SetRotate(m_spCamera->GetWorldRotate());
    m_spCamera->SetRotate(NiMatrix3::IDENTITY);
    m_spRotNode->AttachChild(m_spCamera);
    m_spTrnNode->Update(0.0f);
    
    float fTrnSpeed = 0.05f;
    float fRotSpeed = 0.005f;

    m_kTurret.SetStandardTrn(fTrnSpeed, m_spTrnNode);
    m_kTurret.SetStandardRot(fRotSpeed, m_spTrnNode, m_spRotNode);
    NiMatrix3 kRot;
    kRot.SetCol(0, -1.0f, 0.0f, 0.0f);
    kRot.SetCol(1, 0.0f, -1.0f, 0.0f);
    kRot.SetCol(2, 0.0f, 0.0f, 1.0f);
    m_kTurret.SetAxes(kRot);
    
    if (m_kTurret.GetInputDevice() == NiTurret::TUR_KEYBOARD)
    {
        m_kTurret.SetTrnButtonsKB(2,
            NiInputKeyboard::KEY_W, NiInputKeyboard::KEY_S);
        m_kTurret.SetTrnButtonsKB(1,
            NiInputKeyboard::KEY_Q, NiInputKeyboard::KEY_E);
        m_kTurret.SetTrnButtonsKB(0,
            NiInputKeyboard::KEY_D, NiInputKeyboard::KEY_A);
            
    }
    else if (m_kTurret.GetInputDevice() == NiTurret::TUR_GAMEPAD)
    {
        m_kTurret.SetTrnButtonsStickDirGP(0, 
            NiInputGamePad::NIGP_STICK_LEFT, 
            NiInputGamePad::NIGP_STICK_AXIS_V);
        m_kTurret.SetTrnButtonsGP(1, 
            NiInputGamePad::NIGP_L1, 
            NiInputGamePad::NIGP_R1);
        m_kTurret.SetTrnButtonsStickDirGP(2, 
            NiInputGamePad::NIGP_STICK_LEFT, 
            NiInputGamePad::NIGP_STICK_AXIS_H);

        m_kTurret.SetRotButtonsGP(0, NiInputGamePad::NIGP_NONE,
            NiInputGamePad::NIGP_NONE);
        m_kTurret.SetRotButtonsStickDirGP(1, 
            NiInputGamePad::NIGP_STICK_RIGHT, 
            NiInputGamePad::NIGP_STICK_AXIS_H);
        m_kTurret.SetRotModifiers(1, NiInputGamePad::NIGP_MASK_NONE);
        m_kTurret.SetRotButtonsStickDirGP(2, 
            NiInputGamePad::NIGP_STICK_RIGHT, 
            NiInputGamePad::NIGP_STICK_AXIS_V);
        m_kTurret.SetRotModifiers(2, NiInputGamePad::NIGP_MASK_NONE);
    }
}
//---------------------------------------------------------------------------


void Bowling::processContacts(NxContactPair& pair, NxU32 events) {
	//soundSystem.PlayContactSound();
}

void Bowling::SetCamera(NiCameraPtr cam)
{
	m_spCamera = cam;
}